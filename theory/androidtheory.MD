# 안드로이드의 4대 컴포넌트에 대해서
- 안드로이드의 4대 컴포넌트로는 액티비티, 서비스, 브로드캐스트리시버, 콘텐트 프로바이더가 있습니다.(액서브콘)
## 액티비티
- 안드로이드에서 화면을 관리하고 사용자의 다양한 이벤트를 처리하는데 사용
## 서비스
- 화면에서 보이지 않지만 특정한 기능을 백그라운드에서 처리하는 사용
## 브로드캐스트 리시버 
- 안드로이드에서 발생하는 특정 브로드캐스트 메세지를 처리하기 위한 컴포넌트
## 콘텐트 프로바이더
- 앱사이의 데이터 공유를 위한 인터페이스를 제공하는 컴포넌트

# 안도로이드의 액티비티와 액티비티의 수명주기에 대해서 설명
- 안드로이드에서 화면을 관리하며 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트입니다. 부모 액티비티에서 새로운자식 액티비티를
실행하고자 한다면 먼저 매니페스트 파일에 해당 자식 액티비티를 추가합니다. 다음으로 부모 액티비티에서 startActivity 메소드에 인텐트를
파라미터로 넘겨 실행하거나 startActivities 메소드를 이용하여 여러개의 액티비티를 한꺼번에 실행할 수 있습니다.

액티비티의 실행과정은 첫 번째로 부모 액티비티에서 자식액티비티를 생성 및 호출합니다. 두 번째로 액티비티 매니저 서비스가 해당 앱프로세스
에서 인텐트를 복사해온 후 매니페스트 파일에서 해당 인텐트에 명시되어있는 액티비티를 찾고 어떻게 실행시켜야할지 결정합니다. 세 번째로
찾아낸 액티비티를 실행하고 다시 해당 앱프로세스에 인텐트를 복사하여 넘겨줍니다. 그외 자식 액티비티 내의 onCreate 메소드에서 setContentView
메소드에 레이아웃의 아이디를 파라미터로 넘겨 해당 액티비티의 화면을 구성하게됩니다.

액티비티는 크게 3가지 상태가 존재합니다. 먼저 **실행(Running) 상태**는 액티비티 스택의 최상위에 있으며 포커스를 가지고있어 사용자에게 보이는
상태입니다. 다음으로 **일시중지(paused)상태**는 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어 포커스를 받지 못하는 상태를 말합니다.
예를 들어 대화상자가 위에 있어 일부가 가려져 있는 경우를 말합니다. 마지막으로 **중지상태(Stoped)상태**는 다른 액티비티에 의해 완전히 가려져
보이지 않는 상태를 말합니다.

액티비티가 처음 만들어지면 **onCreate메소드가 호출**되어 레이아웃을 구성합니다. 이후 **onStart 메소드**가 화면에 보이기 직전에 호출됩니다.
다음으로 **onResume 메소드**가 사용자 상호작용(화면이 포커스를 얻을 때)하기 바로전에 호출됩니다. 이 3가지 메소드가 호출되어 액티비티는 실행
상태를 갖게됩니다. 이후 포커스를 잃었을때 **onPaused 메소드**가 호출되고 일시 중지 상태가 됩니다. 일시 중지 상태에서 다시 포커스를 획득하면
**onResume 메소드**가 호출되거나 다른 액티비티에 의해서 화면이 완전히 가려졌는지 여부를 확인하여 가려져보이지않는 경우 **onStop 메소드**가
호출되어 중지 상태가 됩니다. 정지 상태에서 다시 화면이 보이기 직전에 **onRestart 메소드** 호출되고 **onStart 메소드**가 차례로 호출됩니다.
그 외 **finish 메소드**가 실행되어 해당 액티비티가 종료되기 직전에 **onDestory 메소드**가 실행됩니다.

가끔은 일시 중지나 중지 상태에서 시스템이 메모리가 부족하다고 판단될 경우 onCreate 메소드부터 다시 해당 액티비티를 구동합니다. 이 경우 
onCreate 메소드부터 다시 해당 액티비티를 구동합니다. 이 경우 onStop, onResume 메소드 호출이 생략됩니다. 따라서 onSaveInstanceState,
onRestoreInstanceState 메소드를 이용하여 액티비티가 갑자기 죽을 것을 대비해서 상태를 저장하고 복원하기 위한 작업을 정의할수 있습니다.

# 프래그먼트의 생명주기에 대해서 설명하세요.
- onAttach 함수가 onCreate 이전에 호출됩니다. 그 이후 onCreate함수가 호출되고 onCreateView에서 LayoutInflater로 UI관련 작업을 할
수 있습니다. 그리고 화면이 포커스를 잃었을 때는 onPause onStop onDestroyView가 호출되고 종료시에 onDestroy onDetach()가 호출됩니다.

# 안드로이드의 매니페스트 파일에 대해서 설명하세요.
- 매니페스트 파일은 앱의 이름, 버전, 구성요소, 권한 등 앱의 실행에서 꼭 필요한 정보가 저장되어 있는 파일입니다. XML파일로 프로젝트의
최상위에 존재합니다.

태그 구성으로 가장위는 **manifest태그**가 존재하고 패키지명, 버전 등이 기재됩니다.

**application태그**에는 앱 아이콘, 앱 이름 등의 정보가 저장됩니다.

**activity태그**에는 액티비티 클래스명과 액티비티 이름을 정의합니다.
activity 하위에는 intent-filter태그를 이용하여 액티비티에 대한 인텐드 작업시 필요한 action과 category를 정의합니다.

**service,receiver,provider 태그**에는 서비스, 리시버, 프로바이더에 대한 내용이 정의되어 있습니다.

**permission태그**에는 앱에서 필요한 권한을 정의합니다.

그 밖에 sdk버전을 지칭하는 uses-sdk와 다른 패키지를 등록할 수 있는 uses-library 등이 존재합니다.

# 안드로이드에서 인플레이션에 대해 설명하세요,

## WebView란?
안드로이드 프레임워크에 내장된 컴포넌트로 View의 형태로 임베딩 할 수 있는 형태이다.
웹페이지를 보거나 안드로이드 앱 안에서 HTML을 호출하여 앱을 구현하는 하이브리드 형태의 앱을 개발하는데에도 많이 사용된다.

# RxJava란 무엇인가?
- RxJava는 **Reactive Programming(비동기 데이터스트림을 이용한 프로그래밍)** 을 기반으로 한 언어입니다. 
즉, Reactive Extension의 JVM 버전입니다.
비동기 데이터처리를 효율적으로 할 수 있는 장점이 있습니다.
![image](https://user-images.githubusercontent.com/58617250/76698205-72ed8700-66e3-11ea-922a-b7d790414642.png)
RxJava는 반응형 프로그래밍으로 명령형 프로그래밍과 다른 개념입니다.
## 반응형 프로그래밍의 특징(Reactive Programming)
- for if while 같은 것이 아니라 sql 쿼리 같은 선언형으로 구성됩니다.

또 함수를 단지 호출하는 대상이 아니라 변수로도, 혹은 인자로도 넘길 수 있습니다.
이러한 함수형 언어의 도구들을 자유롭게 활용해야 합니다.

# 안드로이드의 태스크란?
- Task는 어플리케이션에서 실행되는 Activity를 관리하는 스택입니다. 선입 후출의 형태로 나중에 적재된 액티비티가 가장 먼저 사용됩니다.
최초적재된 액티비티는 **Root Activity**라고 하고 마지막에 적재된 Activity는 **Top Activity**라고 합니다.
Flag를 이용하여 액티비티의 흐름을 제어할 수 있습니다.

# Realm이란? (SQLite와의 비교) [렐름]
sqlite, realm은 안드로이드 단말에서 사용하는 관계형 데이터베이스입니다.

sqlite는 오픈소스 데이터베이스로 OS와 상호작용하기위해 **SQLiteOpenHelper인터페이스**를 이용합니다. SQLite는 C언어로 되어있고 경량
데이터베이스이며 하나의 디스크 파일에 모든 데이터를 저장할 수 있습니다.

Realm은 크로스 플랫폼 기반의 모바일 데이터베이스입니다. IOS와 Android에서 모두 사용이 가능하며 성능 및 효율성이 우수합니다. 설치도
간편하며 쿼리 응답속도도 기타 OMRLite나 SQLite보다 더 좋습니다. **크로스 플랫폼**이기 때문에 협업에서 유용합니다.

특징으로는 **zero-copy 모델**을 사용하기 때문에 데이터 객체 자체에서 그대로 작업이 가능합니다.
크로스 플랫폼이기 때문에 특정 OS를 가리지 않고 동기화 될 수 있습니다.
ACID를 준수합니다.
Realm은 데이터베이스 컨테이너의 인스턴스입니다.
SQLite 기반의 ORM 프레임 워크입니다.

# Restful API (Representation State Transfer의 약자
- 웹상에 존재하는 모든 자원에 URI를 부여하여 사용하는 방법입니다. (비연결성, URI로 자원에 접근)
HTTP 웹 표준을 이용하며 http의 캐싱을 활용할 수 있다는 장접이 있습니다. 그리고 구조가 명확하여 클라이언트와 서버에서
개발해야할 부분이 명확해지고 URI만 봐도 어떤 요청인지 파악될 수 있게 직관적이다라는 특징이 있습니다.
EX) CTA프로젝트에서 한국환경공단에서 각시도별 실시간 대기오염 정보 API를 이용해서 앱 안에 각시도별 대기오염 정보를 알려줄 수 있도록 하였음.

# FCM의 구동원리 (Firebase Cloud Messaging의 약자)
- 서버 본연의 기능을 수행하면서 또 하나의 복잡한 알림기능까지 포함한다면 서버의 속도는 처리량이 많아 느려질 것입니다. 따라서 이러한 해결책으로
알림의 기능은 다른 서버가 제공을 해주고 본 서버는 알림 기능을 제공하는 서버에 알림이 있는지 요청을 해서 정보를 가져오는 구조입니다.

FCM의 동작을 위해서 **HTTP**나 **XMPP**로 FCM과 통신하는 서버와 클라이언트 앱이 필요합니다.

동작순서
1. 디바이스에 앱이 설치된 후 최초 실행되면서 고유 식별자인 디바이스 토큰이 발급됩니다. 이토큰을 앱서버에 등록합니다.
2. 앱서버에서 FCM 연결 서버로 푸시 알림을 요청합니다. 이때 준비물은 디바이스 토큰과 API 서버 키입니다.
3. FCM 연결 서버는 토큰을 대상으로 알림 메시지를 푸시합니다.

# 하이브리드 앱이란?
- 네이티브 앱처럼 하드웨어의 기능을 사용할 수 있으며 마켓에 등록이 가능하며 배포 후에도 웹만 연결되어 있다면 수정/보완을 할 수 있습니다.
또한 하나의 소스로 아이폰과 안드로이드에 맞게 포장이 가능하며 핵심 부분은 웹 앱 기술로 빠르게 제작이 가능하여 개발 비용이 적어질 수 있습니다.

실제 핵심기능은 코드로 구현하고 지속적으로 업데이트 할 부분은 웹에서 관리하는 기능입니다.

EX)멜론차트

# Looper란 무엇인지 설명하세요.
- Looper는 스레드간의 신호이므로 handler에 보낸다고 해서 **곧바로 처리되는 것이 아닙니다.** 동시다발적으로 메세지가 발생할 수 있기 때문에
**메세지 큐(Message Queue)에 쌓았다가 처리**합니다. **큐에 들어있는 내용을 하나하나 꺼내 처리하는 것이 바로 루퍼**입니다.
**메인 스레드가 Looper를 가지고 있으며 무한 루프를 돌며 큐의 내용을 처리**합니다.

# 스레드 간 통신방법에 대해 설명해보세요.

1. **Java IO**에서 제공하는 파이프를 이용한 방법
2. 스레드 간의 **공유메모리**를 통한 접근(인스턴스 맴버변수, 클래스 맴버변수)
3. **Synchronized**를 이용한 시그널링
4. **BlockingQueue**를 이용한 방법

안드로이드 스레드 통신 메커니즘을 알기 위해서는 android.os 패키지 안의 다음 사항을 알아야합니다.
핸들러 - 루퍼 - 메시지큐 - 메시지
android.os.Looper : UI 스레드에 하나가 존재하며 소비자 스레드와 연관된 메시지 발송자(데이터를 읽는 역할)
                    (소비자 -> 데이터를 읽는다)
android.os.Handler : 큐에 메시지를 삽입하는 생산자 스레드를 위한 인터페이스와 소비자 스레드 메시지 처리, 하나의 Looper 객체는 많은 핸들러
를 갖지만 모두 같은 큐에 삽입
android.os.MessageQueue : 소비자 스레드에서 처리할 메시지들이 담긴 무제한의 연결 리스트. 모든 루퍼와 스레드는 최대 하나의 메시지 큐를 가진다.
andrios.os.Message : 소비자 스레드에서 실행하는 메시지

# intent Flag - FLAG_ACTIVITY_CLEAR_TOP, FLAG_ACTIVITY_SINGLE_TOP에 대해 설명
FLAG_ACTIVITY_CLEAR_TOP - 동일한 액티비티가 쌓일 경우 Root Activity를 남기고 제거.
FLAG_ACTIVITY_SINGLE_TO - 동일한 액티비티가 호출될 경우 1개로 취급.
