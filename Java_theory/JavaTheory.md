# OOP(객체지향프로그래밍)란?
- 데이터를 객체로 취급하여 프로그램에 반영한것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는 다르게 객체의
상호작용을 통해 프로그램이 동작하는 것을 말합니다. 캡슐화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고, 유지
보수를 감소시키는 장점을 얻기 위해서 객체들을 연결시켜 프로그래밍 하는 것입니다.

# Java의 메모리영역
## 1. 메서드 영역
- static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다. 코드에서 사용되는 Class들을 로더로 읽어 클래스
별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.
## 2. 스택(Stack)
- 지역변수, 함수(메서드) 등이 할당되는 LIFO 방식의 메모리
## 3. 힙(Heap)
- new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어짐
## 4. 메모리 상수풀 영역?
- 힙영역(프로그래머가 관리하는 메모리 영역)에 생성되어 자바 프로세스 종료까지 계속 유지되는 메모리 영역입니다. 기본적으로
JVM에서 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고 없으면 상수풀에 추가한 이후 그 주소값을 리턴합니다.
그로인해 메모리 절약 효과가 있습니다.

# 인터페이스란?
- 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든
메서드는 추상메서드로 정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.
## 왜 인터페이스를 사용하는가?
- 팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더
라도 인터페이스의 메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 
알고 있기 때문에 다른 팀의 작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않
아도 된다. 또한, 부가적으로 객체를 파일에 쓰기위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기위햐서
Comparable 인터페이스를 상속하는것, Cloneable을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.

# jdbc란 무엇인가?
- 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법을
제공한다.

# 직렬화란 무엇인가?
- 자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동했습니다. 하지만 객체는 바이트형이 아니라서 스트림을 통해 
파일에 저장하거나 네트워로 전송할 수 없습니다. 따라서 객체를 스트림을 통해 입출력하려면 바이트 배열로 변환하는 것이 필요한데, 이를
'직렬화'라고 합니다. 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 역직렬화라고 합니다.

# serialVersionUID를 선언해야 하는 이유
- 자바가상기계(JVM)는 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여합니다. 만약 그 시점에 클래스의 정의가 바뀌어 있다
면 새로운 버전 번호를 할당합니다. 그래서 직렬화할때의 버전 번호와 역직렬화를 할때의 버전 번호가 다르면 역직렬화가 불가능하게 될수도있습
니다. 이런 문제를 해결하기 위해 SerialVersionUID를 사용합니다.
간단명료하게 **serialVersionUID값을 저장할 때 클래스버전이 맞는지 확인하기 위한 용도입니다.**
만약 직렬화 할때 사용한 SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SerialVersionUID값이 다르다면 InvalidClassException발생

# 리플렉션이란 무엇인가?
- 리플렉션은 컴파일러를 무시하고 런타임 상황에서 메모리에 올라간 클래스나 메서드 등의 정의를 동적으로 찾아서 조작할 수 있는 일련의 행위를
말합니다. 즉, 동적인 언어의 특징이라 말할 수 있습니다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용하기도 합니다.

# 자바의 클래스 멤버 변수 초기화 순서에 대해서 설명하라.
## 1. static 변수 선언부
- 클래스가 로드될 때(메모리 모델상 Method area에 올라감) 변수가 제일 먼저 초기화됨.
## 2. 필드 변수 선언부
- 객체 생성될 때(메모리 모델상 Heap area에 올라감) 생성자 block보다 앞서 초기화함.
## 3. 생성자 block
- 객체 생성 될때 (메모리 모델상 Heap area에 올라감) JVM이 내부적으로 locking(thread safe 영역임)
필드 변수 중 final 변수의 가시화는 (다른 스레드에 공개하느 시점은) 생성자 block이 끝난 다음. 
필드 변수 선언부에서 이미 초기화 되었다면 그 값들은 덮어 씀.
## 초기화 시점
- 클래스 변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다.
- 인스턴스 변수의 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화가 이루어진다.
## 초기화 순서
- 클래스 변수의 초기화 순서 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
- 인스턴스 변수의 초기화 순서 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

# Servlet vs JSP
## 1. Servlet 
- 자바 언어로 웹 개발을 위해 만들어진 것으로, Contatiner가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것
## 2. JSP
- html 기반에 JAVA코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어진 것

# 제너릭
- 클래스를 선언할 때  타입을 결정하지 않고 객체를 생성할 때 유동적인 타입으로 재사용하기 위한 것 형 변환을 할 필요
없고, 타입 에러가 발생할 확률이 없어진다.
타입 추론은 메서드를 호출하는 코드에서 타입인자가 정의한대로 제대로 쓰였는지 살펴보는 컴파일러의 능력이다.

# 컬렉션(collection) 클래스에서 제네릭을 사용하는 이유
- 컬렉션 클래스에서 제네릭을 사용하면 컴파일러는 특정 타입만 포함될 수 있도록 컬렉션을 제한합니다.
컬렉션 클래스에 저장하는 **인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파
일 타임에 잡아낼 수 있도록** 도와줍니다.

# pojo란 무엇인가
- Plain Old Java Object. 간단히 포조라는 말 그대로 해석하며 오래된 방식의 자바 오브젝트로서 J2EE등의 중량 
프레임워크들을 사용하면서 해당 프레임워크에 종속된 무거운 객체를 만들게 된 것에 반발하여 특정 자바 모델이나 
기능, 프레임 워크 등을 따르지 않는 자바 오브젝트를 지칭하는 말로 사용.

# 박싱과 언박싱에 대해서 설명
- 원시형 -> Wrapper Class로 변환 박싱
Wrapper Class -> 원시형으로 변환 언박싱
여기에 명시적, 묵시적으로 변함.

# '데드락'이란 무엇인가? 또한 해결법은?
- 데드락이란, 둘 이상의 쓰레드가 lock을 획득하기 위해 기다리는데, 이 lock를 잡고 있는 쓰레드도 똑같이 다른 lock을
기다리며 서로 블록 상태에 놓이는 것을 말한다. 데드락은 다수의 쓰레드가 같은 lock을, 동시에, 다른명령에 의해, 획득
하려 할 때 발생할 수 있다.  
- 자원유형에 따라 우선순위를 선정하여 자원을 선점하게 한다.
- 공유불가능한 상호 배제의 조건을 제거한다.

# 상속과 합성(컴포지션)의 차이에 대해 설명
- 상속은 is a 관계
- 컴포지션은 has a 관계
상속은 클래스를 확장하여 부모 클래스에서 속성 및 동작을 상속하는 기능이다.
class Engine{}
abstract class Automobile{}
class car extends Automobile{  
        private Engine engine;  
}
합성은 클래스가 구성원 데이터로 다른 클래스의 객체를 포함할 수 있는 능력이다.
ex) 자동차는 엔진이 포함되어 있다.

# JVM의 역할은 무엇인가?
- JVM은 자바를 실행하기 위한 가상 기계라고 할수 있다. 프로그램을 실해앟기 위해 물리적 머신과 유사한 머신을 소프트웨어로
구현한 것이라고 해석할 수 있다. JVM은 Java Byte Code를 OS에 맞게 해석해주는 역할을 한다. Java Compiler가 \*.java 파일
을 컴파일 하면 .class라는 java byte code로 변환시켜 주며, Byte Code는 기계어가 아니기 때문에 OS에서 바로 실행이 되지않
는다. 이 때 JVM이 OS가 이해할 수 있도록 해석해준다.

# Interface
- 일종의 추상클래스로서 오직 추상메서드와 상수만을 멤버로 갖는다. Implements 키워드를 사용하며 상속의 관계가 없는 클래스간
서로 공통되는 로직을 구현하여 쓸 수 있도록 한다. Extends는 하나의 클래스만 상속 가능하나 Interface는 다중상속이 가능하다.
# Abstract
- 추상메서드를 하나 이상 가진 클래스로서 자신을 생성하는 생성자로 객체 생성 불가능하다. 하위클래스를 참조하여 상위 클래스의 객
체를 생성하며, 하위 클래스를 제어하기 위해 사용한다.

# 다형성이란?
- 다형성이란 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.
