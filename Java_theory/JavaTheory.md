# OOP(객체지향프로그래밍)란?
- 데이터를 객체로 취급하여 프로그램에 반영한것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는 다르게 객체의
상호작용을 통해 프로그램이 동작하는 것을 말합니다. 캡슐화, 다형성, 상속을 이용하여 코드 재사용을 증가시키고, 유지
보수를 감소시키는 장점을 얻기 위해서 객체들을 연결시켜 프로그래밍 하는 것입니다.

# Java의 메모리영역
## 1. 메서드 영역
- static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다. 코드에서 사용되는 Class들을 로더로 읽어 클래스
별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.
## 2. 스택(Stack)
- 지역변수, 함수(메서드) 등이 할당되는 LIFO 방식의 메모리
## 3. 힙(Heap)
- new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어짐
## 4. 메모리 상수풀 영역?
- 힙영역(프로그래머가 관리하는 메모리 영역)에 생성되어 자바 프로세스 종료까지 계속 유지되는 메모리 영역입니다. 기본적으로
JVM에서 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고 없으면 상수풀에 추가한 이후 그 주소값을 리턴합니다.
그로인해 메모리 절약 효과가 있습니다.

# 인터페이스란?
- 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든
메서드는 추상메서드로 정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.
## 왜 인터페이스를 사용하는가?
- 팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더
라도 인터페이스의 메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 
알고 있기 때문에 다른 팀의 작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않
아도 된다. 또한, 부가적으로 객체를 파일에 쓰기위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기위햐서
Comparable 인터페이스를 상속하는것, Cloneable을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.

# jdbc란 무엇인가?
- 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법을
제공한다.

# 직렬화란 무엇인가?
- 자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동했습니다. 하지만 객체는 바이트형이 아니라서 스트림을 통해 
파일에 저장하거나 네트워로 전송할 수 없습니다. 따라서 객체를 스트림을 통해 입출력하려면 바이트 배열로 변환하는 것이 필요한데, 이를
'직렬화'라고 합니다. 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 역직렬화라고 합니다.

# serialVersionUID를 선언해야 하는 이유
- 자바가상기계(JVM)는 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여합니다. 만약 그 시점에 클래스의 정의가 바뀌어 있다
면 새로운 버전 번호를 할당합니다. 그래서 직렬화할때의 버전 번호와 역직렬화를 할때의 버전 번호가 다르면 역직렬화가 불가능하게 될수도있습
니다. 이런 문제를 해결하기 위해 SerialVersionUID를 사용합니다.
간단명료하게 **serialVersionUID값을 저장할 때 클래스버전이 맞는지 확인하기 위한 용도입니다.**
만약 직렬화 할때 사용한 SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SerialVersionUID값이 다르다면 InvalidClassException발생

# 리플렉션이란 무엇인가?
- 리플렉션은 컴파일러를 무시하고 런타임 상황에서 메모리에 올라간 클래스나 메서드 등의 정의를 동적으로 찾아서 조작할 수 있는 일련의 행위를
말합니다. 즉, 동적인 언어의 특징이라 말할 수 있습니다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용하기도 합니다.

# 자바의 클래스 멤버 변수 초기화 순서에 대해서 설명하라.
## 1. static 변수 선언부
- 클래스가 로드될 때(메모리 모델상 Method area에 올라감) 변수가 제일 먼저 초기화됨.
## 2. 필드 변수 선언부
- 객체 생성될 때(메모리 모델상 Heap area에 올라감) 생성자 block보다 앞서 초기화함.
## 3. 생성자 block
- 객체 생성 될때 (메모리 모델상 Heap area에 올라감) JVM이 내부적으로 locking(thread safe 영역임)
필드 변수 중 final 변수의 가시화는 (다른 스레드에 공개하느 시점은) 생성자 block이 끝난 다음. 
필드 변수 선언부에서 이미 초기화 되었다면 그 값들은 덮어 씀.
## 초기화 시점
- 클래스 변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다.
- 인스턴스 변수의 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화가 이루어진다.
## 초기화 순서
- 클래스 변수의 초기화 순서 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
- 인스턴스 변수의 초기화 순서 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

# Servlet vs JSP
## 1. Servlet 
- 자바 언어로 웹 개발을 위해 만들어진 것으로, Contatiner가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것
## 2. JSP
- html 기반에 JAVA코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어진 것

# 제너릭
- 클래스를 선언할 때  타입을 결정하지 않고 객체를 생성할 때 유동적인 타입으로 재사용하기 위한 것 형 변환을 할 필요
없고, 타입 에러가 발생할 확률이 없어진다.
타입 추론은 메서드를 호출하는 코드에서 타입인자가 정의한대로 제대로 쓰였는지 살펴보는 컴파일러의 능력이다.
